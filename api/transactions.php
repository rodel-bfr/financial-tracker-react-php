<?php
  /**
   * @file transactions.php
   * @description This script provides the primary API for managing individual transactions.
   * It handles all standard CRUD (Create, Read, Update, Delete) operations for one-off transactions
   * that are NOT generated by a recurring rule. It is the endpoint for the '/transactions' resource.
   */

  // Includes the database connection and common headers script.
  require 'conectare.php';

  /**
   * @function citeste
   * @description A helper function to read and decode the JSON data from the request body.
   * 'php://input' is a read-only stream to get raw POST data.
   * json_decode() converts the JSON string into a PHP associative array.
   * @return array The decoded data from the request.
   */
  function citeste() {
      return json_decode(file_get_contents('php://input'), true);
  }

  // --- 1. READ (GET) ---
  /**
   * @function executaGET
   * @description Handles HTTP GET requests to fetch all transactions.
   * @param mysqli $cnx The active database connection.
   */
    function executaGET($cnx) {
        $raspuns = [];
        
        // This SQL query is the heart of the data retrieval for the main dashboard.
        // It selects all columns from the transactions table (aliased as 't').
        // It uses a LEFT JOIN to also fetch the category name and type from the 'categories' table ('c').
        // A LEFT JOIN is used so that if a transaction's category was deleted, the transaction itself will still appear.
        // It also explicitly selects the 'recurring_income_id' and 'recurring_expense_id' so the frontend can identify recurring transactions.
        $cda = "SELECT t.id, t.description, t.amount, t.type, t.category_id, t.transaction_date, t.recurring_income_id, t.recurring_expense_id, c.name as category_name, c.type as category_type FROM transactions t LEFT JOIN categories c ON t.category_id = c.id ORDER BY t.transaction_date DESC, t.id DESC";
        
        if ($rez = mysqli_query($cnx, $cda)) {
            while ($linie = mysqli_fetch_assoc($rez)) {
                $raspuns[] = $linie;
            }
            mysqli_free_result($rez); // Free the memory used by the result set.
        }
        // Encode the final array of transactions into JSON format and send it as the response.
        echo json_encode($raspuns);
    }

  // --- 2. CREATE (POST) ---
  /**
   * @function executaPOST
   * @description Handles HTTP POST requests to add a new manual transaction.
   * @param mysqli $cnx The active database connection.
   */
  function executaPOST($cnx) {
      // Get the transaction data from the request body.
      $data = citeste();
      
      // Use a prepared statement to prevent SQL injection, a critical security practice.
      // The '?' are placeholders for the actual data.
      $stmt = mysqli_prepare($cnx, "INSERT INTO transactions(description, amount, type, category_id, transaction_date) VALUES (?, ?, ?, ?, ?)");
      
      // Bind the variables from the $data array to the prepared statement.
      // 'sdsis' specifies the data type for each parameter: s=string, d=double, i=integer.
      mysqli_stmt_bind_param($stmt, 'sdsis', $data['description'], $data['amount'], $data['type'], $data['category_id'], $data['transaction_date']);
      
      if (mysqli_stmt_execute($stmt)) {
          // If successful, send a success response including the ID of the newly created record.
          echo json_encode(['rezultat' => "OK", 'id' => mysqli_stmt_insert_id($stmt)]);
      } else {
          // If it fails, send an error message from the database.
          echo json_encode(['rezultat' => 'Eroare: ' . mysqli_error($cnx)]);
      }
  }

  // --- 3. UPDATE (PATCH) ---
  /**
   * @function executaPATCH
   * @description Handles HTTP PATCH requests to update an existing manual transaction.
   * @param mysqli $cnx The active database connection.
   */
  function executaPATCH($cnx) {
      $data = citeste();
      
      $stmt = mysqli_prepare($cnx, "UPDATE transactions SET description=?, amount=?, type=?, category_id=?, transaction_date=? WHERE id=?");
      
      // Bind parameters. The final 'i' is for the integer ID in the WHERE clause.
      mysqli_stmt_bind_param($stmt, 'sdsisi', $data['description'], $data['amount'], $data['type'], $data['category_id'], $data['transaction_date'], $data['id']);
      
      if (mysqli_stmt_execute($stmt)) {
          echo json_encode(['rezultat' => "OK"]);
      } else {
          echo json_encode(['rezultat' => 'Eroare: ' . mysqli_error($cnx)]);
      }
  }

  // --- 4. DELETE (DELETE) ---
  /**
   * @function executaDELETE
   * @description Handles HTTP DELETE requests to remove a manual transaction.
   * @param mysqli $cnx The active database connection.
   */
  function executaDELETE($cnx) {
      $data = citeste();
      
      $stmt = mysqli_prepare($cnx, "DELETE FROM transactions WHERE id = ?");
      
      mysqli_stmt_bind_param($stmt, 'i', $data['id']);
      
      if (mysqli_stmt_execute($stmt)) {
          echo json_encode(['rezultat' => "OK"]);
      } else {
          echo json_encode(['rezultat' => 'Eroare: ' . mysqli_error($cnx)]);
      }
  }

  // --- 5. Main Request Router ---
  // This part checks the HTTP method of the request (GET, POST, PATCH, DELETE).
  $metoda = $_SERVER['REQUEST_METHOD'];
  
  // The switch statement calls the appropriate function based on the request method.
  // This is a common pattern for building simple REST APIs in PHP.
  switch ($metoda) {
      case 'GET': executaGET($cnx); break;
      case 'POST': executaPOST($cnx); break;
      case 'PATCH': executaPATCH($cnx); break;
      case 'DELETE': executaDELETE($cnx); break;
  }
  
  // Close the database connection after the operation is complete to free up resources.
  mysqli_close($cnx);
?>